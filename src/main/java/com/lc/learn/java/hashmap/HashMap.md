1.hashMap 

hashcode()：hashcode()大概就是为了获得哈希码也称为散列码，哈希码的作用是确定该对象在哈希表中的索引位置。
           
           hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。
           虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，
           该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，
           或者创建类的对象数组等等)，类的hashCode() 没有作用。

      讲下HashMap中的实现原理，hashmap是由数组和链表组成的。数组是HashMap的本体，而链表则是为了解决hash冲突而存在的，
      如果定位到数组位置不存在链表（当前Entry的next指向为null），那么对于查找插入等操作很快，仅仅需要一次寻址即可；
      如果定位到数组有链表，对于添加操作其时间复杂度为O（n）,首先遍历链表，存在既覆盖，否则新增。对于查找操作来讲，
      仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。
      
      以下是具体的 put 过程（JDK1.8）
      
      对 Key 求 Hash 值，然后再计算下标
      如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）如果碰撞了，以链表的方式链接到后面
      如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表
      如果节点已经存在就替换旧值
      如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）
      
减少hash冲突？扰动函数可以减少碰撞
    原理是如果两个不相等的对象返回不同的 hashcode 的话，那么碰撞的几率就会小些。这就意味着存链表结构减小，
    这样取值的话就不会频繁调用 equal 方法，从而提高 HashMap 的性能（扰动即 Hash 方法内部的算法实现，
    目的是让不同对象返回不同hashcode）。
    使用不可变的、声明作 final 对象，并且采用合适的 equals() 和 hashCode() 方法，将会减少碰撞的发生不可变性使得能够缓存不同键的 
    hashcode，这将提高整个获取对象的速度，使用 String、Integer 这样的 wrapper 类作为键是非常好的选择。
    为什么 String、Integer 这样的 wrapper 类适合作为键？
    因为 String 是 final，而且已经重写了 equals() 和 hashCode() 方法了。不可变性是必要的，因为为了要计算 hashCode()，
    就要防止键值改变，如果键值在放入时和获取时返回不同的 hashcode 的话，那么就不能从 HashMap 中找到你想要的对象。     
    
1、什么是哈希冲突？
    哈希冲突就是指当插入一个Entry<k,v>时，将key经过hash计算出的下标中已经存在另一个Entry<k,v>，这时就会产生哈希冲突。
   
    那么HashMap采用的是哪种方法呢？
    要知道HashMap采用哪种方法就要知道它的实现原理。
    众所周知，HasMap的底层是通过数组+链表实现的。此处的“链表”就是HashMap为我们提供的解决哈希冲突的方法。也就是连地址法。     